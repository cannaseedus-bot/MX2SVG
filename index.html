<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ULTRA NEURAL GEOMETRY STACK — PRIME COCKPIT</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --bg: #0f1117;
      --panel: #151821;
      --accent: #19c37d;
      --accent-soft: rgba(25,195,125,0.2);
      --muted: #8b93a7;
      --danger: #ff6b6b;
      --border: rgba(148,163,184,0.2);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #0b0d12;
      color: #e6edf3;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      padding: 16px;
    }
    .grid {
      max-width: 1280px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 320px) minmax(0, 1fr);
      gap: 16px;
    }
    .panel {
      background: var(--panel);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 16px;
      box-shadow: 0 24px 40px rgba(0,0,0,0.3);
    }
    .panel h2 {
      font-size: 1rem;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }
    .badge {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: .12em;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.6);
    }
    .badge--accent {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(22,242,170,0.05);
    }
    .status-line {
      font-size: 0.75rem;
      color: var(--muted);
      margin: 4px 0;
    }
    select, button {
      background: #0b0f17;
      color: #e5f3ff;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 6px 10px;
      font-size: 0.8rem;
      outline: none;
    }
    button {
      cursor: pointer;
      border-color: var(--accent);
      background: rgba(25,195,125,0.12);
    }
    button:hover {
      box-shadow: 0 0 18px rgba(25,195,125,0.35);
    }
    .ctrl-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 8px 0 4px;
      align-items: center;
    }
    .session-meta {
      display: grid;
      gap: 6px;
      margin-bottom: 12px;
      font-size: 0.8rem;
      color: var(--muted);
    }
    .session-meta span {
      color: #e6edf3;
      font-weight: 600;
    }
    .chat-history {
      display: flex;
      flex-direction: column;
      gap: 12px;
      height: 520px;
      overflow: auto;
      padding-right: 8px;
    }
    .chat-message {
      background: #0f141e;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 0.85rem;
      line-height: 1.4;
    }
    .chat-message--user {
      border-color: rgba(25,195,125,0.4);
      background: rgba(25,195,125,0.08);
    }
    .chat-message__role {
      text-transform: uppercase;
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .chat-form {
      display: grid;
      gap: 12px;
      height: 100%;
    }
    .chat-form textarea {
      width: 100%;
      min-height: 220px;
      background: #0b0f17;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      color: #e6edf3;
      font-size: 0.9rem;
      resize: vertical;
    }
    .chat-form__footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.75rem;
      color: var(--muted);
    }
    .chat-form__footer button {
      padding: 8px 16px;
      font-size: 0.85rem;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: minmax(0,1fr); }
    }
  </style>
  <script id="inline-manifest" type="application/json">
    {
      "name": "ASX PRIME — ULTRA Neural Geometry Stack",
      "short_name": "ULTRA-NEURAL",
      "version": "2.1.0",
      "start_url": "/",
      "scope": "/",
      "display": "standalone",
      "background_color": "#020617",
      "theme_color": "#16f2aa",
      "description": "K'uhul + KLH + XJSON + SCXQ2 + SVG Neural Geometry Engine",
      "icons": [
        {
          "src": "icon-192.png",
          "sizes": "192x192",
          "type": "image/png"
        },
        {
          "src": "icon-512.png",
          "sizes": "512x512",
          "type": "image/png"
        }
      ],
      "x_asx": {
        "Ωv": "2.1",
        "n": "ASX-PRIME-TRINITY-OS",
        "d": "Complete Browser OS with Kernel Processes + SVG Neural Geometry",
        "⟁kproc": {
          "⟁fs": {
            "⟁t": "vfs",
            "⟁d": "xj_vfs",
            "⟁m": [
              {"⟁p": "/sys", "⟁t": "ro", "⟁s": "scx_sys"},
              {"⟁p": "/usr", "⟁t": "rw", "⟁s": "store"},
              {"⟁p": "/tmp", "⟁t": "vol", "⟁s": "mem"}
            ]
          },
          "⟁pm": {
            "⟁t": "kuhl_sched",
            "⟁max": 256,
            "⟁mem": "16m",
            "⟁iso": "glyph"
          },
          "⟁net": {
            "⟁t": "vnet",
            "⟁proto": ["http", "ws", "hive"],
            "⟁route": "klh"
          },
          "⟁sec": {
            "⟁t": "trust_stamp",
            "⟁sand": "glyph_env"
          },
          "⟁comp": {
            "⟁t": "scx_zip",
            "⟁alg": ["sym", "huff", "dict"]
          }
        },
        "swarm_protocol": {
          "mode": "holographic",
          "shard_size": "micro-atomic",
          "indexing": "scxq2-hash-map",
          "mount_points": {
            "global_memory": "magnet:?xt=urn:btih:HIVE_MEMORY_HASH",
            "agent_hive": "magnet:?xt=urn:btih:AGENT_SWARM_HASH"
          },
          "caching": "flash-ram-lru",
          "behavior": "fetch-on-demand"
        },
        "brain_protocol": {
          "format": "svg_qlora_scxq2",
          "slots": 16,
          "geometry": "svg_path",
          "compression": "scxq2",
          "engine": "kuhul_geometry",
          "mounts": [
            { "id": "mx2lm_core", "mode": "read-write" },
            { "id": "qwen_adapter", "mode": "read-only" },
            { "id": "arena_brain", "mode": "read-write" }
          ]
        },
        "⟁scx_tools": {
          "⟁code_zip": {
            "⟁in": ["khl", "js", "xj"],
            "⟁out": "scx",
            "⟁ratio": "87%"
          },
          "⟁asset_zip": {
            "⟁in": ["svg", "img", "font"],
            "⟁out": "scx_sym"
          },
          "⟁data_zip": {
            "⟁in": ["xj_ast", "api", "state"],
            "⟁out": "scx_struct"
          },
          "⟁rt_zip": {
            "⟁mode": "stream",
            "⟁latency": "<1ms"
          }
        },
        "⟁sys_svc": {
          "⟁db": {
            "⟁t": "xj_db",
            "⟁eng": {
              "⟁kv": "scx_kv",
              "⟁doc": "xj_doc",
              "⟁graph": "glyph_rel"
            }
          },
          "⟁auth": {
            "⟁t": "trust_auth",
            "⟁prov": ["local", "hive", "asx"]
          },
          "⟁cache": {
            "⟁t": "multi_cache",
            "⟁layers": [
              {"⟁n": "mem", "⟁s": "64m", "⟁strat": "lru"},
              {"⟁n": "flash", "⟁s": "256m", "⟁strat": "pri"},
              {"⟁n": "persist", "⟁s": "1g", "⟁strat": "lfu"}
            ]
          },
          "⟁sched": {
            "⟁t": "glyph_sched",
            "⟁tasks": ["bg_sync", "cache_clean", "comp_jobs"]
          },
          "⟁log": {
            "⟁t": "struct_log",
            "⟁out": "xj_logs",
            "⟁comp": "scx_stream"
          }
        },
        "⟁boot": [
          "manifest.load",
          "scx_dict.load",
          "svg_rt.init",
          "kuhl.init",
          "kproc.mount",
          "sys_svc.start",
          "scx_tools.init",
          "micronaut.mount",
          "swarm.mount",
          "brain_store.mount",
          "klh.init",
          "fs.mount",
          "sec.activate",
          "index.render",
          "user.start",
          "ready"
        ]
      }
    }
  </script>
  <script id="inline-sw" type="text/plain">
// ULTRA NEURAL GEOMETRY STACK — ΩOS TRINITY SERVICE WORKER
// K'uhul + KLH + XJSON + SCXQ2 + SVG Brain Store (no DOM here)

// ----------------------------------------------------------
// CORE CONSTANTS
// ----------------------------------------------------------
const KUHUL_OS = 'kuhul-ultra-neuro-v1';
const KERNEL_CACHE = `${KUHUL_OS}-kernel`;
const STATIC_CACHE = `${KUHUL_OS}-static`;

const CORE_ASSETS = [
  '/',
  '/index.html'
];

// ----------------------------------------------------------
// LIGHTWEIGHT KERNEL (K) — PROCESS TABLE
// ----------------------------------------------------------
const K = {
  p: new Map(),   // processes
  w: new Map(),   // weights / brains / registry

  async run(id, code, ctx = {}) {
    const proc = { id, code, ctx, st: 'run', ts: Date.now() };
    this.p.set(id, proc);
    // In this SW edition we don't execute glyphs fully;
    // we just register process + return context.
    return { id, res: 'ok', ctx };
  },

  status() {
    return {
      processes: this.p.size,
      registry: this.w.size,
      ts: Date.now()
    };
  }
};

// ----------------------------------------------------------
// SCXQ2 PATH CODEC (ULTRA-LITE)
// ----------------------------------------------------------
const SCXQ2 = {
  encodePath(pathData) {
    return pathData
      .replace(/M /g, '⟁M⟁')
      .replace(/L /g, '⟁L⟁')
      .replace(/C /g, '⟁C⟁')
      .replace(/Z/g, '⟁Z⟁')
      .replace(/,/g, '⟁')
      .replace(/\s+/g, '⟁');
  },
  decodePath(comp) {
    return comp
      .replace(/⟁M⟁/g, 'M ')
      .replace(/⟁L⟁/g, 'L ')
      .replace(/⟁C⟁/g, 'C ')
      .replace(/⟁Z⟁/g, 'Z')
      .replace(/⟁/g, ' ');
  }
};

// ----------------------------------------------------------
// BRAIN STORE — SCXQ2 PACKED SVG GEOMETRY
// ----------------------------------------------------------
const BrainStore = {
  brains: new Map(),   // brainId -> { meta, layers }

  initDemoBrains() {
    if (this.brains.size) return;

    // DEMO BRAIN #1 — "mx2lm_core" geometry (synthetic)
    const b1 = {
      id: 'mx2lm_core_svg',
      model: 'MX2LM-CORE-GEOMETRY',
      type: 'svg_qlora_scxq2',
      created: Date.now(),
      layers: [
        {
          name: 'lora_A',
          filter: null,
          paths: [
            {
              d: SCXQ2.encodePath(
                'M 0,10 C 20,5 40,15 60,10 C 80,5 100,15 120,10'
              ),
              stroke: 'rgb(255,0,80)',
              width: 1.5
            },
            {
              d: SCXQ2.encodePath(
                'M 0,20 C 20,25 40,15 60,20 C 80,25 100,15 120,20'
              ),
              stroke: 'rgb(80,160,255)',
              width: 1.2
            }
          ]
        },
        {
          name: 'lora_B',
          filter: null,
          paths: [
            {
              d: SCXQ2.encodePath(
                'M 0,40 C 30,60 60,20 90,40 C 120,60 150,20 180,40'
              ),
              stroke: 'rgb(255,160,0)',
              width: 1.8
            }
          ]
        }
      ]
    };

    // DEMO BRAIN #2 — "arena_brain" geometry (synthetic)
    const b2 = {
      id: 'arena_brain_svg',
      model: 'ARENA-BATTLE-BRAIN',
      type: 'svg_qlora_scxq2',
      created: Date.now(),
      layers: [
        {
          name: 'risk_map',
          filter: null,
          paths: [
            {
              d: SCXQ2.encodePath(
                'M 10,80 L 40,60 L 70,90 L 100,70 L 130,100'
              ),
              stroke: 'rgb(22,242,170)',
              width: 2.0
            }
          ]
        }
      ]
    };

    this.brains.set(b1.id, b1);
    this.brains.set(b2.id, b2);

    // Also mirror into kernel registry
    K.w.set(b1.id, b1);
    K.w.set(b2.id, b2);
  },

  list() {
    return Array.from(this.brains.values()).map(b => ({
      id: b.id,
      model: b.model,
      type: b.type,
      created: b.created
    }));
  },

  get(id) {
    const b = this.brains.get(id);
    if (!b) return null;

    // decode paths on the way out
    return {
      id: b.id,
      model: b.model,
      type: b.type,
      created: b.created,
      layers: b.layers.map(layer => ({
        name: layer.name,
        filter: layer.filter,
        paths: layer.paths.map(p => ({
          d: SCXQ2.decodePath(p.d),
          stroke: p.stroke,
          width: p.width
        }))
      }))
    };
  },

  // hook for future: pack raw weights from /usr into SCXQ2 geometry
  async packFromWeights(id, weightsMeta = {}) {
    // placeholder pipeline: in real mode this would map QLoRA -> SVG -> SCXQ2
    const synthetic = {
      id,
      model: weightsMeta.model || 'CUSTOM-GEOMETRY',
      type: 'svg_qlora_scxq2',
      created: Date.now(),
      layers: [
        {
          name: 'custom_layer',
          filter: null,
          paths: [
            {
              d: SCXQ2.encodePath('M 0,0 C 30,30 60,-10 90,10'),
              stroke: 'rgb(180,80,255)',
              width: 1.4
            }
          ]
        }
      ]
    };
    this.brains.set(id, synthetic);
    K.w.set(id, synthetic);
    return synthetic;
  }
};

// ----------------------------------------------------------
// ΩOS MANIFEST (KERNEL VIEW)
// ----------------------------------------------------------
const ΩMANIFEST_KERNEL = {
  Ωv: '2.1',
  n: 'ASX-PRIME-TRINITY-OS',
  d: 'Browser OS + Neural Geometry Kernel',
  brain_protocol: {
    format: 'svg_qlora_scxq2',
    slots: 16,
    engine: 'kuhul_geometry',
    registry: 'sw_brain_store'
  }
};

// ----------------------------------------------------------
// ΩOS API ROUTER
// ----------------------------------------------------------
async function respondΩOS(requestUrl, request) {
  const path = requestUrl.pathname.replace(/^\/api\/ΩOS\//, '');
  const parts = path.split('/').filter(Boolean);

  // /api/ΩOS/status
  if (parts[0] === 'status') {
    return new Response(JSON.stringify({
      kernel: 'ΩOS-ULTRA',
      version: ΩMANIFEST_KERNEL.Ωv,
      k: K.status(),
      brain_slots: ΩMANIFEST_KERNEL.brain_protocol.slots
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  }

  // /api/ΩOS/brains/*
  if (parts[0] === 'brains') {
    // /api/ΩOS/brains/list
    if (parts[1] === 'list') {
      const list = BrainStore.list();
      return new Response(JSON.stringify({ brains: list }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // /api/ΩOS/brains/get/:id
    if (parts[1] === 'get' && parts[2]) {
      const id = decodeURIComponent(parts[2]);
      const brain = BrainStore.get(id);
      if (!brain) {
        return new Response(JSON.stringify({ error: 'brain_not_found', id }), {
          status: 404,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      return new Response(JSON.stringify({ brain }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // /api/ΩOS/brains/pack (future: pack from weights/xjson)
    if (parts[1] === 'pack' && request.method === 'POST') {
      const body = await request.json().catch(() => ({}));
      const id = body.id || `brain_${Date.now()}`;
      const meta = body.meta || {};
      const brain = await BrainStore.packFromWeights(id, meta);
      return new Response(JSON.stringify({ brain }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }

  // /api/ΩOS/process/list
  if (parts[0] === 'process' && parts[1] === 'list') {
    const processes = Array.from(K.p.values()).map(p => ({
      id: p.id,
      st: p.st,
      ts: p.ts
    }));
    return new Response(JSON.stringify({ processes }), {
      headers: { 'Content-Type': 'application/json' }
    });
  }

  return new Response(JSON.stringify({ error: 'ΩOS_endpoint_not_found', path }), {
    status: 404,
    headers: { 'Content-Type': 'application/json' }
  });
}

// ----------------------------------------------------------
// SW LIFECYCLE
// ----------------------------------------------------------
self.addEventListener('install', event => {
  event.waitUntil((async () => {
    BrainStore.initDemoBrains();
    const cache = await caches.open(KERNEL_CACHE);
    await cache.addAll(CORE_ASSETS);
    self.skipWaiting();
  })());
});

self.addEventListener('activate', event => {
  event.waitUntil((async () => {
    const keys = await caches.keys();
    await Promise.all(
      keys
        .filter(k => !k.startsWith(KUHUL_OS))
        .map(k => caches.delete(k))
    );
    await self.clients.claim();

    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'ΩOS:kernel_ready',
        kernel: ΩMANIFEST_KERNEL,
        brains: BrainStore.list()
      });
    });
  })());
});

// ----------------------------------------------------------
// FETCH — ROUTE ΩOS + CACHE
// ----------------------------------------------------------
self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);

  // ΩOS API
  if (url.pathname.startsWith('/api/ΩOS/')) {
    event.respondWith(respondΩOS(url, event.request));
    return;
  }

  // NAVIGATION → app shell
  if (event.request.mode === 'navigate') {
    event.respondWith((async () => {
      const cache = await caches.open(KERNEL_CACHE);
      const cached = await cache.match('/index.html');
      if (cached) return cached;
      try {
        const net = await fetch('/index.html');
        cache.put('/index.html', net.clone());
        return net;
      } catch {
        return new Response(
          '<html><body style="background:#020617;color:#e8fff6;font-family:system-ui">' +
            '<h1>ΩOS OFFLINE</h1>' +
            '<p>Neural geometry kernel unavailable.</p>' +
          '</body></html>',
          { headers: { 'Content-Type': 'text/html' } }
        );
      }
    })());
    return;
  }

  // Static with cache-first
  event.respondWith((async () => {
    const cache = await caches.open(STATIC_CACHE);
    const cached = await cache.match(event.request);
    if (cached) return cached;
    try {
      const net = await fetch(event.request);
      cache.put(event.request, net.clone());
      return net;
    } catch {
      return new Response('ΩOS: fetch failed', { status: 503 });
    }
  })());
});

// ----------------------------------------------------------
// MESSAGE CHANNEL — KERNEL / BRAIN CONTROL
// ----------------------------------------------------------
self.addEventListener('message', event => {
  const { type, payload } = event.data || {};
  const port = event.ports && event.ports[0];

  if (type === 'ΩOS:status') {
    port && port.postMessage({
      ok: true,
      kernel: ΩMANIFEST_KERNEL,
      k: K.status(),
      brains: BrainStore.list()
    });
  }

  if (type === 'ΩOS:brains:list') {
    port && port.postMessage({
      ok: true,
      brains: BrainStore.list()
    });
  }

  if (type === 'ΩOS:brains:get' && payload?.id) {
    const brain = BrainStore.get(payload.id);
    port && port.postMessage({
      ok: !!brain,
      brain
    });
  }
});

console.log('ΩOS ULTRA NEURAL GEOMETRY KERNEL — SERVICE WORKER ONLINE');
  </script>
</head>
<body>
  <div class="grid">
    <!-- LEFT: SESSION / CHAT HISTORY -->
    <section class="panel">
      <h2>SESSION CONTEXT</h2>
      <div class="badge-row">
        <span class="badge badge--accent">K'UHUL</span>
        <span class="badge">KLH</span>
        <span class="badge">XJSON</span>
        <span class="badge">SCXQ2</span>
        <span class="badge">SVG-3D</span>
      </div>

      <div class="session-meta">
        <div>Session ID: <span id="sessionId">—</span></div>
        <div>Kernel: <span id="statusLine">probing…</span></div>
        <div>Brains: <span id="brainCount">—</span></div>
        <div>Processes: <span id="procCount">—</span></div>
      </div>

      <div class="chat-history" id="chatHistory"></div>
    </section>

    <!-- RIGHT: CHAT INPUT -->
    <section class="panel">
      <h2>CHAT CONSOLE</h2>
      <form class="chat-form" id="chatForm">
        <textarea id="chatInput" placeholder="Send a message to the SVG-3D tensor inference runtime..."></textarea>
        <div class="chat-form__footer">
          <span>Responses are recorded to the session log.</span>
          <button type="submit">Send Message</button>
        </div>
      </form>
    </section>
  </div>

  <script>
    const chatHistory = document.getElementById('chatHistory');
    const statusLine = document.getElementById('statusLine');
    const brainCountEl = document.getElementById('brainCount');
    const procCountEl = document.getElementById('procCount');
    const sessionIdEl = document.getElementById('sessionId');
    const chatForm = document.getElementById('chatForm');
    const chatInput = document.getElementById('chatInput');
    const manifestScript = document.getElementById('inline-manifest');
    const swScript = document.getElementById('inline-sw');
    const sessionId = `sess_${Math.random().toString(36).slice(2, 10)}`;
    const messages = [];

    sessionIdEl.textContent = sessionId;

    function appendMessage(role, content) {
      const container = document.createElement('div');
      container.className = `chat-message chat-message--${role}`;

      const roleLine = document.createElement('div');
      roleLine.className = 'chat-message__role';
      roleLine.textContent = role === 'user' ? 'user' : 'system';

      const body = document.createElement('div');
      body.textContent = content;

      container.appendChild(roleLine);
      container.appendChild(body);
      chatHistory.appendChild(container);
      chatHistory.scrollTop = chatHistory.scrollHeight;
    }

    function initManifest() {
      if (!manifestScript) return;
      const manifestText = manifestScript.textContent.trim();
      if (!manifestText) return;
      const manifest = JSON.parse(manifestText);
      const blob = new Blob([JSON.stringify(manifest)], {
        type: 'application/manifest+json'
      });
      const manifestUrl = URL.createObjectURL(blob);
      const link = document.createElement('link');
      link.rel = 'manifest';
      link.href = manifestUrl;
      document.head.appendChild(link);
    }

    async function registerSW() {
      if (!('serviceWorker' in navigator)) {
        statusLine.textContent = 'Kernel: service workers unsupported';
        return;
      }
      const swSource = swScript ? swScript.textContent : '';
      if (!swSource) {
        statusLine.textContent = 'Kernel: inline worker missing';
        appendMessage('system', 'Service worker source missing.');
        return;
      }
      const swBlob = new Blob([swSource], { type: 'text/javascript' });
      const swUrl = URL.createObjectURL(swBlob);
      const reg = await navigator.serviceWorker.register(swUrl, { scope: '/' });
      statusLine.textContent = 'Kernel: registering…';
      appendMessage('system', 'Service worker registration requested.');

      navigator.serviceWorker.addEventListener('message', ev => {
        if (ev.data?.type === 'ΩOS:kernel_ready') {
          statusLine.textContent = 'Kernel: ready';
          brainCountEl.textContent = `Brains: ${ev.data.brains.length}`;
          procCountEl.textContent = `Processes: 0`;
          populateBrains(ev.data.brains);
          appendMessage('system', 'Kernel broadcast: ready.');
        }
      });

      await navigator.serviceWorker.ready;
      statusLine.textContent = 'Kernel: ready (await)';
      appendMessage('system', 'Service worker ready.');

      await refreshStatus();
    }

    function sendMessage(type, payload) {
      return new Promise(resolve => {
        if (!navigator.serviceWorker.controller) {
          resolve(null);
          return;
        }
        const channel = new MessageChannel();
        channel.port1.onmessage = ev => resolve(ev.data);
        navigator.serviceWorker.controller.postMessage({ type, payload }, [channel.port2]);
      });
    }

    async function refreshStatus() {
      const res = await sendMessage('ΩOS:status', {});
      if (!res) return;
      statusLine.textContent = 'Kernel: online';
      brainCountEl.textContent = `Brains: ${res.brains.length}`;
      procCountEl.textContent = `Processes: ${res.k.processes}`;
      populateBrains(res.brains);
      appendMessage('system', 'Status refreshed from ΩOS.');
    }

    async function fetchBrainsList() {
      const res = await fetch('/api/ΩOS/brains/list').catch(() => null);
      if (!res || !res.ok) {
        appendMessage('system', 'Brains list fetch failed.');
        return;
      }
      const json = await res.json();
      brainCountEl.textContent = `${json.brains.length}`;
      appendMessage('system', `Brain registry updated (${json.brains.length}).`);
    }

    chatForm.addEventListener('submit', event => {
      event.preventDefault();
      const content = chatInput.value.trim();
      if (!content) return;
      messages.push({ role: 'user', content, ts: new Date().toISOString() });
      appendMessage('user', content);
      chatInput.value = '';
    });

    // ------------------------------------------------------
    // BOOT
    // ------------------------------------------------------
    initManifest();
    registerSW().catch(err => {
      console.error(err);
      statusLine.textContent = 'Kernel: registration error';
      appendMessage('system', 'Error registering service worker.');
    });

    fetchBrainsList().catch(() => {
      appendMessage('system', 'Unable to reach ΩOS brain registry.');
    });
  </script>
</body>
</html>

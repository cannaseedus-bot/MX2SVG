<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ULTRA NEURAL GEOMETRY STACK — PRIME COCKPIT</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="manifest" href="manifest.json">
  <style>
    :root {
      --bg: #020617;
      --panel: #050b18;
      --accent: #16f2aa;
      --accent-soft: rgba(22,242,170,0.2);
      --muted: #7f8ea3;
      --danger: #ff6b6b;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: radial-gradient(circle at top, #020617 0, #000 55%);
      color: #e8f5ff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      padding: 16px;
    }
    .grid {
      max-width: 1280px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 320px) minmax(0, 1fr);
      gap: 16px;
    }
    .panel {
      background: linear-gradient(145deg, #050b18, #050815);
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.35);
      padding: 16px;
      box-shadow: 0 0 40px rgba(0,0,0,0.6);
    }
    .panel h2 {
      font-size: 1rem;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }
    .badge {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: .12em;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
    }
    .badge--accent {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(22,242,170,0.05);
    }
    .status-line {
      font-size: 0.75rem;
      color: var(--muted);
      margin: 4px 0;
    }
    select, button {
      background: #020617;
      color: #e5f3ff;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 6px 10px;
      font-size: 0.8rem;
      outline: none;
    }
    button {
      cursor: pointer;
      border-color: var(--accent);
      background: radial-gradient(circle at top left, rgba(22,242,170,0.18), #020617);
    }
    button:hover {
      box-shadow: 0 0 18px rgba(22,242,170,0.4);
    }
    .ctrl-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 8px 0 4px;
      align-items: center;
    }
    .log {
      margin-top: 8px;
      background: #020617;
      border-radius: 10px;
      padding: 8px;
      font-size: 0.7rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      max-height: 150px;
      overflow: auto;
      border: 1px solid rgba(15,23,42,0.9);
    }
    .section-divider {
      margin: 16px 0 8px;
      border-top: 1px solid rgba(148,163,184,0.3);
      padding-top: 12px;
    }
    .section-title {
      font-size: 0.8rem;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 6px;
    }
    .engine-log {
      background: rgba(2,6,23,0.85);
      border-radius: 10px;
      padding: 8px;
      font-size: 0.7rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      max-height: 120px;
      overflow: auto;
      border: 1px solid rgba(22,242,170,0.2);
      color: #d9f8ff;
    }
    #brainContainer {
      width: 100%;
      height: 480px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.4);
      background:
        radial-gradient(circle at top, rgba(22,242,170,0.06), transparent 55%),
        radial-gradient(circle at bottom, rgba(56,189,248,0.06), transparent 55%),
        #020617;
      position: relative;
      overflow: hidden;
    }
    .brain-title {
      position: absolute;
      top: 10px;
      left: 14px;
      font-size: 0.8rem;
      color: var(--muted);
      background: rgba(0,0,0,0.65);
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      pointer-events: none;
    }
    .brain-overlay {
      position: absolute;
      bottom: 10px;
      right: 14px;
      font-size: 0.7rem;
      color: var(--accent);
      background: rgba(3,7,18,0.9);
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(22,242,170,0.4);
      pointer-events: none;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: minmax(0,1fr); }
      #brainContainer { height: 360px; }
    }
  </style>
</head>
<body>
  <div class="grid">
    <!-- LEFT: KERNEL + BRAIN CONTROL -->
    <section class="panel">
      <h2>ΩOS TRINITY KERNEL</h2>
      <div class="badge-row">
        <span class="badge badge--accent">K'UHUL</span>
        <span class="badge">KLH</span>
        <span class="badge">XJSON</span>
        <span class="badge">SCXQ2</span>
        <span class="badge">SVG&nbsp;NEURO</span>
      </div>

      <div class="status-line" id="statusLine">Kernel: probing…</div>
      <div class="status-line" id="brainCount">Brains: —</div>
      <div class="status-line" id="procCount">Processes: —</div>

      <div class="ctrl-row">
        <button id="btnRefresh">Refresh Kernel</button>
        <button id="btnListBrains">List Brains</button>
      </div>

      <div class="ctrl-row">
        <label for="brainSelect" style="font-size:0.75rem;color:var(--muted);">
          Active Brain:
        </label>
        <select id="brainSelect"></select>
        <button id="btnRenderBrain">Render Brain</button>
      </div>

      <div class="log" id="log"></div>

      <div class="section-divider">
        <div class="section-title">SVG-QLoRA Geometry Engine</div>
        <div class="ctrl-row">
          <button id="btnGenerateGeometry">Generate SVG Brain</button>
          <button id="btnCompressGeometry">Compress SCXQ2</button>
        </div>
        <div class="ctrl-row">
          <label for="geometrySelect" style="font-size:0.75rem;color:var(--muted);">
            Demo Brain:
          </label>
          <select id="geometrySelect">
            <option value="baseball_chip">Baseball Analytics</option>
            <option value="finance_chip">Quantitative Finance</option>
            <option value="creative_chip">Creative Writing</option>
          </select>
        </div>
        <div class="engine-log" id="engineLog"></div>
      </div>
    </section>

    <!-- RIGHT: SVG NEURAL GEOMETRY VIEWPORT -->
    <section class="panel">
      <h2>NEURAL GEOMETRY VIEWPORT</h2>
      <div id="brainContainer">
        <div class="brain-title" id="brainTitle">No brain loaded</div>
        <div class="brain-overlay" id="brainOverlay">ULTRA NEURAL GEOMETRY STACK</div>
      </div>
    </section>
  </div>

  <script>
    // ------------------------------------------------------
    // SVG BRAIN RENDERER (FRONT-END VISUAL CORTEX)
    // ------------------------------------------------------
    class SVGBrainRenderer {
      constructor(containerId) {
        this.container = document.getElementById(containerId);
      }

      clear() {
        while (this.container.firstChild) {
          this.container.removeChild(this.container.firstChild);
        }
      }

      setOverlays(titleText) {
        const title = document.getElementById('brainTitle');
        const overlay = document.getElementById('brainOverlay');
        if (title) {
          title.textContent = titleText;
          this.container.appendChild(title);
        }
        if (overlay) {
          this.container.appendChild(overlay);
        }
      }

      render(brain) {
        this.clear();

        // Re-add overlays
        this.setOverlays(`${brain.model} — ${brain.id}`);

        const ns = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(ns, 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 240 140');

        brain.layers.forEach((layer, idx) => {
          const g = document.createElementNS(ns, 'g');
          g.setAttribute('class', 'neural-layer');
          g.setAttribute('transform', `translate(10,${15 + idx * 35})`);

          // label
          const label = document.createElementNS(ns, 'text');
          label.setAttribute('x', 0);
          label.setAttribute('y', -4);
          label.setAttribute('fill', '#9ca3af');
          label.setAttribute('font-size', '6');
          label.setAttribute('font-family', 'monospace');
          label.textContent = layer.name;
          g.appendChild(label);

          layer.paths.forEach(p => {
            const path = document.createElementNS(ns, 'path');
            path.setAttribute('d', p.d);
            path.setAttribute('stroke', p.stroke);
            path.setAttribute('stroke-width', p.width || 1.2);
            path.setAttribute('fill', 'none');
            path.style.opacity = 0.75;
            path.classList.add('weight-path');

            path.addEventListener('mouseenter', () => {
              path.style.strokeWidth = (p.width || 1.2) * 1.8;
              path.style.opacity = 1;
            });
            path.addEventListener('mouseleave', () => {
              path.style.strokeWidth = p.width || 1.2;
              path.style.opacity = 0.75;
            });

            g.appendChild(path);
          });

          svg.appendChild(g);
        });

        this.container.appendChild(svg);
      }
    }

    const brainRenderer = new SVGBrainRenderer('brainContainer');

    // ------------------------------------------------------
    // SVG-QLoRA GEOMETRY ENGINE
    // ------------------------------------------------------
    class SVGWeightGeometry {
      constructor() {
        this.weightPaths = new Map();
        this.layerGroups = new Map();
        this.activationFilters = new Map();
      }

      weightsToSVG(weights, layerName, config = {}) {
        const {
          precision = 3,
          scale = 100
        } = config;

        const svgData = {
          type: 'weight_layer',
          layer: layerName,
          dimensions: weights.shape,
          paths: []
        };

        if (weights.rank === 2) {
          const [rows, cols] = weights.shape;
          for (let i = 0; i < rows; i += 1) {
            const pathData = this.matrixRowToPath(weights.data[i], {
              rowIndex: i,
              totalRows: rows,
              scale,
              precision
            });
            svgData.paths.push({
              type: 'weight_row',
              index: i,
              d: pathData,
              stroke: this.weightToColor(weights.data[i][0]),
              'stroke-width': this.weightToStroke(weights.norm())
            });
          }
        }
      }

        return svgData;
      }

      matrixRowToPath(rowWeights, config) {
        const { rowIndex, totalRows, scale, precision } = config;
        const yBase = (rowIndex / totalRows) * scale;
        let pathData = `M 0,${yBase.toFixed(precision)}`;

        rowWeights.forEach((weight, colIndex) => {
          const x = (colIndex / rowWeights.length) * scale;
          const y = yBase + (weight * scale * 0.3);

          if (colIndex > 0) {
            const prevX = ((colIndex - 1) / rowWeights.length) * scale;
            const prevY = yBase + (rowWeights[colIndex - 1] * scale * 0.3);

            const cp1x = prevX + (x - prevX) * 0.3;
            const cp1y = prevY;
            const cp2x = prevX + (x - prevX) * 0.7;
            const cp2y = y;

            pathData += ` C ${cp1x.toFixed(precision)},${cp1y.toFixed(precision)} ${cp2x.toFixed(precision)},${cp2y.toFixed(precision)} ${x.toFixed(precision)},${y.toFixed(precision)}`;
          } else {
            pathData += ` L ${x.toFixed(precision)},${y.toFixed(precision)}`;
          }
        });

        return pathData;
      }

      activationToFilter(activationType) {
        const filterId = `activation_${activationType}_${Date.now()}`;

        switch (activationType) {
          case 'relu':
            return {
              id: filterId,
              svg: `
            <filter id="${filterId}" x="-0.1" y="-0.1" width="1.2" height="1.2">
              <feComponentTransfer>
                <feFuncR type="linear" slope="1" intercept="0"/>
                <feFuncG type="linear" slope="1" intercept="0"/>
                <feFuncB type="linear" slope="1" intercept="0"/>
                <feFuncA type="linear" slope="1" intercept="0">
                  <animate attributeName="intercept" values="0;0;1;1" dur="0.001s" fill="freeze"/>
                </feFuncA>
              </feComponentTransfer>
            </filter>
          `
            };
          case 'sigmoid':
            return {
              id: filterId,
              svg: `
            <filter id="${filterId}">
              <feComponentTransfer>
                <feFuncR type="table" tableValues="0 0 0.5 1 1 1"/>
                <feFuncG type="table" tableValues="0 0 0.5 1 1 1"/>
                <feFuncB type="table" tableValues="0 0 0.5 1 1 1"/>
              </feComponentTransfer>
            </filter>
          `
            };
          case 'tanh':
            return {
              id: filterId,
              svg: `
            <filter id="${filterId}">
              <feComponentTransfer>
                <feFuncR type="table" tableValues="-1 -0.5 0 0.5 1"/>
                <feFuncG type="table" tableValues="-1 -0.5 0 0.5 1"/>
                <feFuncB type="table" tableValues="-1 -0.5 0 0.5 1"/>
              </feComponentTransfer>
            </filter>
          `
            };
          default:
            return null;
        }
      }

      weightToColor(weight) {
        if (weight < 0) {
          const intensity = Math.min(1, Math.abs(weight) * 2);
          return `rgb(0, 0, ${Math.floor(255 * intensity)})`;
        }
        const intensity = Math.min(1, weight * 2);
        return `rgb(${Math.floor(255 * intensity)}, 0, 0)`;
      }

      weightToStroke(norm) {
        return Math.max(0.5, Math.min(3, norm * 2));
      }

      networkToSVG(modelWeights, architecture) {
        const svgLayers = [];
        const defs = [];

        architecture.layers.forEach(layer => {
          const filter = this.activationToFilter(layer.activation);
          if (filter) {
            defs.push(filter.svg);
            this.activationFilters.set(layer.name, filter.id);
          }
        });

        architecture.layers.forEach(layer => {
          const layerWeights = modelWeights[layer.name];
          if (layerWeights) {
            const layerSVG = this.weightsToSVG(layerWeights, layer.name);
            layerSVG.filter = this.activationFilters.get(layer.name);
            svgLayers.push(layerSVG);
          }
        });

        return {
          defs: defs.join('\n'),
          layers: svgLayers,
          metadata: {
            type: 'neural_network_svg',
            architecture: architecture.name,
            totalParams: this.countParameters(modelWeights),
            generated: new Date().toISOString()
          }
        };
      }

      countParameters(modelWeights) {
        return Object.values(modelWeights).reduce((total, weights) => {
          const [rows, cols] = weights.shape;
          return total + (rows * cols);
        }, 0);
      }

      renderSVGBrain(networkSVG, containerId, titleText) {
        const container = document.getElementById(containerId);
        if (!container) return null;

        brainRenderer.clear();
        brainRenderer.setOverlays(titleText);

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 800 600');
        svg.style.background = '#0a0a1a';

        const defsElement = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defsElement.innerHTML = networkSVG.defs;
        svg.appendChild(defsElement);

        networkSVG.layers.forEach((layer, index) => {
          const layerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          layerGroup.setAttribute('class', `neural-layer layer-${index}`);
          layerGroup.setAttribute('transform', `translate(${index * 120 + 50}, 80)`);

          const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          label.setAttribute('x', 0);
          label.setAttribute('y', -12);
          label.setAttribute('fill', '#16f2aa');
          label.setAttribute('font-size', '10');
          label.setAttribute('font-family', 'monospace');
          label.textContent = layer.layer;
          layerGroup.appendChild(label);

          layer.paths.forEach(pathData => {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData.d);
            path.setAttribute('stroke', pathData.stroke);
            path.setAttribute('stroke-width', pathData['stroke-width']);
            path.setAttribute('fill', 'none');

            if (layer.filter) {
              path.setAttribute('filter', `url(#${layer.filter})`);
            }

            path.style.opacity = '0.7';
            path.addEventListener('mouseenter', () => {
              path.style.strokeWidth = '4';
              path.style.opacity = '1';
            });
            path.addEventListener('mouseleave', () => {
              path.style.strokeWidth = pathData['stroke-width'];
              path.style.opacity = '0.7';
            });

            layerGroup.appendChild(path);
          });

          svg.appendChild(layerGroup);
        });

        container.appendChild(svg);
        return svg;
      }
    }

    class SVGQLoRACompressor {
      constructor() {
        this.geometryEngine = new SVGWeightGeometry();
        this.compressionRegistry = new Map();
      }

      async compressQLoRAToSVG(qloraWeights, modelName, config = {}) {
        const {
          quantization = 8,
          compression = 'scxq2'
        } = config;

        const svgBrain = this.geometryEngine.networkToSVG(qloraWeights, {
          name: modelName,
          layers: Object.keys(qloraWeights).map(key => ({
            name: key,
            activation: 'linear'
          }))
        });

        if (quantization < 32) {
          svgBrain.layers = this.quantizeSVGPaths(svgBrain.layers, quantization);
        }

        if (compression === 'scxq2') {
          return this.compressSVGWithSCXQ2(svgBrain, modelName);
        }

        return svgBrain;
      }

      quantizeSVGPaths(layers, bits) {
        return layers.map(layer => ({
          ...layer,
          paths: layer.paths.map(path => ({
            ...path,
            d: this.quantizePathData(path.d, bits)
          }))
        }));
      }

      quantizePathData(pathData, bits) {
        const numbers = (pathData.match(/[-+]?\\d*\\.?\\d+/g) || []).map(Number);
        const maxVal = Math.pow(2, bits) - 1;

        let quantizedPath = pathData;
        numbers.forEach((original, index) => {
          const normalized = (original + 1) / 2;
          const quantized = Math.round(normalized * maxVal);
          const dequantized = (quantized / maxVal) * 2 - 1;
          quantizedPath = quantizedPath.replace(original.toString(), dequantized.toFixed(3));
        });

        return quantizedPath;
      }

      async compressSVGWithSCXQ2(svgBrain, modelName) {
        const compressed = {
          type: 'svg_qlora_brain',
          model: modelName,
          version: '1.0',
          compressed: true,
          data: {}
        };

        svgBrain.layers.forEach(layer => {
          compressed.data[layer.layer] = {
            paths: layer.paths.map(path => ({
              d: this.scxq2CompressPath(path.d),
              metadata: {
                stroke: path.stroke,
                width: path['stroke-width']
              }
            })),
            filter: layer.filter
          };
        });

        const brainId = `brain_${modelName}_${Date.now()}`;
        this.compressionRegistry.set(brainId, compressed);

        return {
          brainId,
          originalSize: JSON.stringify(svgBrain).length,
          compressedSize: JSON.stringify(compressed).length,
          compressionRatio: JSON.stringify(svgBrain).length / JSON.stringify(compressed).length
        };
      }

      scxq2CompressPath(pathData) {
        return pathData
          .replace(/M /g, '⟁M⟁')
          .replace(/L /g, '⟁L⟁')
          .replace(/C /g, '⟁C⟁')
          .replace(/Z/g, '⟁Z⟁')
          .replace(/,/g, '⟁')
          .replace(/\\s+/g, '⟁');
      }

      scxq2DecompressPath(compressedPath) {
        return compressedPath
          .replace(/⟁M⟁/g, 'M ')
          .replace(/⟁L⟁/g, 'L ')
          .replace(/⟁C⟁/g, 'C ')
          .replace(/⟁Z⟁/g, 'Z')
          .replace(/⟁/g, ' ');
      }

      async loadCompressedBrain(brainId, containerId) {
        const compressed = this.compressionRegistry.get(brainId);
        if (!compressed) throw new Error(`Brain ${brainId} not found`);

        const svgBrain = {
          defs: '',
          layers: Object.entries(compressed.data).map(([layerName, layerData]) => ({
            layer: layerName,
            paths: layerData.paths.map(path => ({
              d: this.scxq2DecompressPath(path.d),
              stroke: path.metadata.stroke,
              'stroke-width': path.metadata.width
            })),
            filter: layerData.filter
          }))
        };

        return this.geometryEngine.renderSVGBrain(svgBrain, containerId, `SCXQ2 ${compressed.model}`);
      }
    }

    // ------------------------------------------------------
    // SW UTILS
    // ------------------------------------------------------
    const logEl = document.getElementById('log');
    const engineLogEl = document.getElementById('engineLog');
    const statusLine = document.getElementById('statusLine');
    const brainCountEl = document.getElementById('brainCount');
    const procCountEl = document.getElementById('procCount');
    const brainSelect = document.getElementById('brainSelect');
    const geometrySelect = document.getElementById('geometrySelect');

    const svgGeometryEngine = new SVGWeightGeometry();
    const svgCompressor = new SVGQLoRACompressor();

    function logEngine(msg) {
      const time = new Date().toISOString().split('T')[1].replace('Z','');
      engineLogEl.textContent = `[${time}] ${msg}\n` + engineLogEl.textContent;
    }

    function log(msg) {
      const time = new Date().toISOString().split('T')[1].replace('Z','');
      logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
    }

    async function registerSW() {
      if (!('serviceWorker' in navigator)) {
        statusLine.textContent = 'Kernel: service workers unsupported';
        return;
      }
      const reg = await navigator.serviceWorker.register('/sw.js');
      statusLine.textContent = 'Kernel: registering…';
      log('Service worker registration requested');

      navigator.serviceWorker.addEventListener('message', ev => {
        if (ev.data?.type === 'ΩOS:kernel_ready') {
          statusLine.textContent = 'Kernel: ready';
          brainCountEl.textContent = `Brains: ${ev.data.brains.length}`;
          procCountEl.textContent = `Processes: 0`;
          populateBrains(ev.data.brains);
          log('Kernel broadcast: ready');
        }
      });

      await navigator.serviceWorker.ready;
      statusLine.textContent = 'Kernel: ready (await)';
      log('Service worker ready');

      await refreshStatus();
    }

    function sendMessage(type, payload) {
      return new Promise(resolve => {
        if (!navigator.serviceWorker.controller) {
          resolve(null);
          return;
        }
        const channel = new MessageChannel();
        channel.port1.onmessage = ev => resolve(ev.data);
        navigator.serviceWorker.controller.postMessage({ type, payload }, [channel.port2]);
      });
    }

    async function refreshStatus() {
      const res = await sendMessage('ΩOS:status', {});
      if (!res) return;
      statusLine.textContent = 'Kernel: online';
      brainCountEl.textContent = `Brains: ${res.brains.length}`;
      procCountEl.textContent = `Processes: ${res.k.processes}`;
      populateBrains(res.brains);
      log('Status refreshed from ΩOS');
    }

    function populateBrains(brains) {
      brainSelect.innerHTML = '';
      brains.forEach(b => {
        const opt = document.createElement('option');
        opt.value = b.id;
        opt.textContent = `${b.model} (${b.id})`;
        brainSelect.appendChild(opt);
      });
      if (!brains.length) {
        const opt = document.createElement('option');
        opt.textContent = 'No brains in registry';
        opt.disabled = true;
        opt.selected = true;
        brainSelect.appendChild(opt);
      }
    }

    async function fetchBrainsList() {
      const res = await fetch('/api/ΩOS/brains/list').catch(() => null);
      if (!res || !res.ok) {
        log('Brains list fetch failed');
        return;
      }
      const json = await res.json();
      populateBrains(json.brains || []);
      brainCountEl.textContent = `Brains: ${json.brains.length}`;
      log(`Brain list updated (${json.brains.length})`);
    }

    async function renderSelectedBrain() {
      const id = brainSelect.value;
      if (!id) return;
      const res = await fetch(`/api/ΩOS/brains/get/${encodeURIComponent(id)}`).catch(() => null);
      if (!res || !res.ok) {
        log(`Failed to fetch brain ${id}`);
        return;
      }
      const json = await res.json();
      if (!json.brain) {
        log(`No brain payload for ${id}`);
        return;
      }
      brainRenderer.render(json.brain);
      log(`Rendered brain: ${json.brain.model} (${json.brain.id})`);
    }

    function createDemoWeights(seed) {
      const rows = 24;
      const cols = 48;
      const makeMatrix = (factor) => Array.from({ length: rows }, (_, i) =>
        Array.from({ length: cols }, (_, j) =>
          Math.sin((i + factor) * 0.1) * Math.cos((j + seed) * 0.07) * 0.5
        )
      );

      return {
        lora_A: {
          shape: [rows, cols],
          rank: 2,
          data: makeMatrix(1),
          norm() { return 0.8; }
        },
        lora_B: {
          shape: [rows, cols],
          rank: 2,
          data: makeMatrix(2),
          norm() { return 0.6; }
        }
      };
    }

    async function generateSVGBrain() {
      const demoKey = geometrySelect.value;
      const weights = createDemoWeights(demoKey.length);
      const svgBrain = svgGeometryEngine.networkToSVG(weights, {
        name: demoKey,
        layers: [
          { name: 'lora_A', activation: 'relu' },
          { name: 'lora_B', activation: 'tanh' }
        ]
      });

      svgGeometryEngine.renderSVGBrain(svgBrain, 'brainContainer', `SVG QLoRA — ${demoKey}`);
      logEngine(`Generated SVG brain for ${demoKey} (${svgBrain.metadata.totalParams} params)`);
    }

    async function compressSVGBrain() {
      const demoKey = geometrySelect.value;
      const weights = createDemoWeights(demoKey.length);
      const result = await svgCompressor.compressQLoRAToSVG(weights, demoKey, { compression: 'scxq2', quantization: 8 });
      logEngine(`Compressed ${demoKey}: ${result.compressionRatio.toFixed(2)}x (${result.brainId})`);
      await svgCompressor.loadCompressedBrain(result.brainId, 'brainContainer');
    }

    // ------------------------------------------------------
    // WIRE UI
    // ------------------------------------------------------
    document.getElementById('btnRefresh').addEventListener('click', refreshStatus);
    document.getElementById('btnListBrains').addEventListener('click', fetchBrainsList);
    document.getElementById('btnRenderBrain').addEventListener('click', renderSelectedBrain);
    document.getElementById('btnGenerateGeometry').addEventListener('click', generateSVGBrain);
    document.getElementById('btnCompressGeometry').addEventListener('click', compressSVGBrain);

    // ------------------------------------------------------
    // BOOT
    // ------------------------------------------------------
    registerSW().catch(err => {
      console.error(err);
      statusLine.textContent = 'Kernel: registration error';
      log('Error registering service worker');
    });
  </script>
</body>
</html>

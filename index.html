<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ULTRA NEURAL GEOMETRY STACK — PRIME COCKPIT</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="manifest" href="manifest.json">
  <style>
    :root {
      --bg: #020617;
      --panel: #050b18;
      --accent: #16f2aa;
      --accent-soft: rgba(22,242,170,0.2);
      --muted: #7f8ea3;
      --danger: #ff6b6b;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: radial-gradient(circle at top, #020617 0, #000 55%);
      color: #e8f5ff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      padding: 16px;
    }
    .grid {
      max-width: 1280px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: minmax(0, 320px) minmax(0, 1fr);
      gap: 16px;
    }
    .panel {
      background: linear-gradient(145deg, #050b18, #050815);
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.35);
      padding: 16px;
      box-shadow: 0 0 40px rgba(0,0,0,0.6);
    }
    .panel h2 {
      font-size: 1rem;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 8px;
    }
    .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }
    .badge {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: .12em;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
      background: rgba(15,23,42,0.9);
    }
    .badge--accent {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(22,242,170,0.05);
    }
    .status-line {
      font-size: 0.75rem;
      color: var(--muted);
      margin: 4px 0;
    }
    select, button {
      background: #020617;
      color: #e5f3ff;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      padding: 6px 10px;
      font-size: 0.8rem;
      outline: none;
    }
    button {
      cursor: pointer;
      border-color: var(--accent);
      background: radial-gradient(circle at top left, rgba(22,242,170,0.18), #020617);
    }
    button:hover {
      box-shadow: 0 0 18px rgba(22,242,170,0.4);
    }
    .ctrl-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 8px 0 4px;
      align-items: center;
    }
    .ctrl-row--stack {
      flex-direction: column;
      align-items: flex-start;
    }
    .ctrl-row--stack .ctrl-row {
      margin: 4px 0 0;
    }
    .panel-divider {
      height: 1px;
      background: rgba(148,163,184,0.25);
      margin: 12px 0;
    }
    .log {
      margin-top: 8px;
      background: #020617;
      border-radius: 10px;
      padding: 8px;
      font-size: 0.7rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      max-height: 150px;
      overflow: auto;
      border: 1px solid rgba(15,23,42,0.9);
    }
    #brainContainer {
      width: 100%;
      height: 480px;
      border-radius: 16px;
      border: 1px solid rgba(148,163,184,0.4);
      background:
        radial-gradient(circle at top, rgba(22,242,170,0.06), transparent 55%),
        radial-gradient(circle at bottom, rgba(56,189,248,0.06), transparent 55%),
        #020617;
      position: relative;
      overflow: hidden;
    }
    .brain-title {
      position: absolute;
      top: 10px;
      left: 14px;
      font-size: 0.8rem;
      color: var(--muted);
      background: rgba(0,0,0,0.65);
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.5);
      pointer-events: none;
    }
    .brain-overlay {
      position: absolute;
      bottom: 10px;
      right: 14px;
      font-size: 0.7rem;
      color: var(--accent);
      background: rgba(3,7,18,0.9);
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(22,242,170,0.4);
      pointer-events: none;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: minmax(0,1fr); }
      #brainContainer { height: 360px; }
    }
  </style>
</head>
<body>
  <div class="grid">
    <!-- LEFT: KERNEL + BRAIN CONTROL -->
    <section class="panel">
      <h2>ΩOS TRINITY KERNEL</h2>
      <div class="badge-row">
        <span class="badge badge--accent">K'UHUL</span>
        <span class="badge">KLH</span>
        <span class="badge">XJSON</span>
        <span class="badge">SCXQ2</span>
        <span class="badge">SVG&nbsp;NEURO</span>
      </div>

      <div class="status-line" id="statusLine">Kernel: probing…</div>
      <div class="status-line" id="brainCount">Brains: —</div>
      <div class="status-line" id="procCount">Processes: —</div>

      <div class="ctrl-row">
        <button id="btnRefresh">Refresh Kernel</button>
        <button id="btnListBrains">List Brains</button>
      </div>

      <div class="ctrl-row">
        <label for="brainSelect" style="font-size:0.75rem;color:var(--muted);">
          Active Brain:
        </label>
        <select id="brainSelect"></select>
        <button id="btnRenderBrain">Render Brain</button>
      </div>

      <div class="panel-divider"></div>

      <div class="ctrl-row ctrl-row--stack">
        <div class="status-line">SVG-QLoRA Geometry Engine</div>
        <div class="ctrl-row">
          <button id="btnGenerateSVG">Generate SVG Brain</button>
          <button id="btnCompressSVG">Compress SCXQ2</button>
        </div>
        <div class="status-line" id="svgStatus">Geometry: idle</div>
      </div>

      <div class="log" id="log"></div>
    </section>

    <!-- RIGHT: SVG NEURAL GEOMETRY VIEWPORT -->
    <section class="panel">
      <h2>NEURAL GEOMETRY VIEWPORT</h2>
      <div id="brainContainer">
        <div class="brain-title" id="brainTitle">No brain loaded</div>
        <div class="brain-overlay" id="brainOverlay">ULTRA NEURAL GEOMETRY STACK</div>
      </div>
    </section>
  </div>

  <script>
    // ------------------------------------------------------
    // SVG WEIGHT GEOMETRY ENGINE
    // ------------------------------------------------------
    class SVGWeightGeometry {
      constructor() {
        this.activationFilters = new Map();
      }

      weightsToSVG(weights, layerName, config = {}) {
        const {
          precision = 3,
          scale = 120
        } = config;

        const svgData = {
          type: 'weight_layer',
          layer: layerName,
          dimensions: weights.shape,
          paths: []
        };

        if (weights.rank === 2) {
          const [rows] = weights.shape;

          for (let i = 0; i < rows; i += 1) {
            const pathData = this.matrixRowToPath(weights.data[i], {
              rowIndex: i,
              totalRows: rows,
              scale,
              precision
            });

            svgData.paths.push({
              type: 'weight_row',
              index: i,
              d: pathData,
              stroke: this.weightToColor(weights.data[i][0] || 0),
              width: this.weightToStroke(weights.data[i])
            });
          }
        }

        return svgData;
      }

      matrixRowToPath(rowWeights, config) {
        const { rowIndex, totalRows, scale, precision } = config;
        const yBase = (rowIndex / Math.max(1, totalRows)) * scale;

        let pathData = `M 0,${yBase.toFixed(precision)}`;

        rowWeights.forEach((weight, colIndex) => {
          const x = (colIndex / Math.max(1, rowWeights.length - 1)) * scale;
          const y = yBase + (weight * scale * 0.3);

          if (colIndex > 0) {
            const prevX = ((colIndex - 1) / Math.max(1, rowWeights.length - 1)) * scale;
            const prevY = yBase + (rowWeights[colIndex - 1] * scale * 0.3);

            const cp1x = prevX + (x - prevX) * 0.3;
            const cp1y = prevY;
            const cp2x = prevX + (x - prevX) * 0.7;
            const cp2y = y;

            pathData += ` C ${cp1x.toFixed(precision)},${cp1y.toFixed(precision)} ${cp2x.toFixed(precision)},${cp2y.toFixed(precision)} ${x.toFixed(precision)},${y.toFixed(precision)}`;
          } else {
            pathData += ` L ${x.toFixed(precision)},${y.toFixed(precision)}`;
          }
        });

        return pathData;
      }

      activationToFilter(activationType) {
        const filterId = `activation_${activationType}_${Date.now()}`;

        switch (activationType) {
          case 'relu':
            return {
              id: filterId,
              svg: `
                <filter id="${filterId}" x="-0.1" y="-0.1" width="1.2" height="1.2">
                  <feComponentTransfer>
                    <feFuncR type="linear" slope="1" intercept="0"/>
                    <feFuncG type="linear" slope="1" intercept="0"/>
                    <feFuncB type="linear" slope="1" intercept="0"/>
                    <feFuncA type="linear" slope="1" intercept="0"/>
                  </feComponentTransfer>
                </filter>
              `
            };
          case 'sigmoid':
            return {
              id: filterId,
              svg: `
                <filter id="${filterId}">
                  <feComponentTransfer>
                    <feFuncR type="table" tableValues="0 0 0.5 1 1 1"/>
                    <feFuncG type="table" tableValues="0 0 0.5 1 1 1"/>
                    <feFuncB type="table" tableValues="0 0 0.5 1 1 1"/>
                  </feComponentTransfer>
                </filter>
              `
            };
          case 'tanh':
            return {
              id: filterId,
              svg: `
                <filter id="${filterId}">
                  <feComponentTransfer>
                    <feFuncR type="table" tableValues="-1 -0.5 0 0.5 1"/>
                    <feFuncG type="table" tableValues="-1 -0.5 0 0.5 1"/>
                    <feFuncB type="table" tableValues="-1 -0.5 0 0.5 1"/>
                  </feComponentTransfer>
                </filter>
              `
            };
          default:
            return {
              id: filterId,
              svg: `
                <filter id="${filterId}">
                  <feComponentTransfer>
                    <feFuncR type="linear" slope="1" intercept="0"/>
                    <feFuncG type="linear" slope="1" intercept="0"/>
                    <feFuncB type="linear" slope="1" intercept="0"/>
                  </feComponentTransfer>
                </filter>
              `
            };
        }
      }

      weightToColor(weight) {
        if (weight < 0) {
          const intensity = Math.min(1, Math.abs(weight) * 2);
          return `rgb(0, 0, ${Math.floor(255 * intensity)})`;
        }
        const intensity = Math.min(1, weight * 2);
        return `rgb(${Math.floor(255 * intensity)}, 0, 0)`;
      }

      weightToStroke(rowWeights) {
        const norm = rowWeights.reduce((acc, val) => acc + Math.abs(val), 0) / Math.max(1, rowWeights.length);
        return Math.max(0.5, Math.min(3, norm * 4));
      }

      networkToSVG(modelWeights, architecture) {
        const svgLayers = [];
        const defs = [];

        architecture.layers.forEach(layer => {
          const filter = this.activationToFilter(layer.activation);
          defs.push(filter.svg);
          this.activationFilters.set(layer.name, filter.id);
        });

        architecture.layers.forEach(layer => {
          const layerWeights = modelWeights[layer.name];
          if (layerWeights) {
            const layerSVG = this.weightsToSVG(layerWeights, layer.name);
            layerSVG.filter = this.activationFilters.get(layer.name);
            svgLayers.push(layerSVG);
          }
        });

        return {
          defs: defs.join('\n'),
          layers: svgLayers,
          metadata: {
            type: 'neural_network_svg',
            architecture: architecture.name,
            totalParams: Object.values(modelWeights).reduce((acc, w) => acc + w.data.length, 0),
            generated: new Date().toISOString()
          }
        };
      }
    }

    // ------------------------------------------------------
    // SVG-QLORA COMPRESSION ENGINE
    // ------------------------------------------------------
    class SVGQLoRACompressor {
      constructor() {
        this.geometryEngine = new SVGWeightGeometry();
        this.compressionRegistry = new Map();
      }

      async compressQLoRAToSVG(qloraWeights, modelName, config = {}) {
        const {
          quantization = 8,
          compression = 'scxq2'
        } = config;

        const svgBrain = this.geometryEngine.networkToSVG(qloraWeights, {
          name: modelName,
          layers: Object.keys(qloraWeights).map(key => ({
            name: key,
            activation: 'linear'
          }))
        });

        if (quantization < 32) {
          svgBrain.layers = this.quantizeSVGPaths(svgBrain.layers, quantization);
        }

        if (compression === 'scxq2') {
          return this.compressSVGWithSCXQ2(svgBrain, modelName);
        }

        return {
          brainId: `${modelName}_svg`,
          svg: svgBrain
        };
      }

      quantizeSVGPaths(layers, bits) {
        return layers.map(layer => ({
          ...layer,
          paths: layer.paths.map(path => ({
            ...path,
            d: this.quantizePathData(path.d, bits)
          }))
        }));
      }

      quantizePathData(pathData, bits) {
        const numbers = (pathData.match(/[-+]?\\d*\\.?\\d+/g) || []).map(Number);
        if (!numbers.length) return pathData;
        const maxVal = Math.pow(2, bits) - 1;
        let index = 0;
        return pathData.replace(/[-+]?\\d*\\.?\\d+/g, match => {
          const num = numbers[index];
          const normalized = Math.max(0, Math.min(1, (num + 1) / 2));
          const quantized = Math.round(normalized * maxVal);
          const dequantized = (quantized / maxVal) * 2 - 1;
          index += 1;
          return dequantized.toFixed(3);
        });
      }

      compressSVGWithSCXQ2(svgBrain, modelName) {
        const compressed = {
          type: 'svg_qlora_brain',
          model: modelName,
          version: '1.0',
          compressed: true,
          data: {}
        };

        svgBrain.layers.forEach(layer => {
          compressed.data[layer.layer] = {
            paths: layer.paths.map(path => ({
              d: this.scxq2CompressPath(path.d),
              metadata: {
                stroke: path.stroke,
                width: path.width
              }
            })),
            filter: layer.filter
          };
        });

        const brainId = `brain_${modelName}_${Date.now()}`;
        this.compressionRegistry.set(brainId, compressed);

        return {
          brainId,
          originalSize: JSON.stringify(svgBrain).length,
          compressedSize: JSON.stringify(compressed).length,
          compressionRatio: JSON.stringify(svgBrain).length / Math.max(1, JSON.stringify(compressed).length)
        };
      }

      scxq2CompressPath(pathData) {
        return pathData
          .replace(/M /g, '⟁M⟁')
          .replace(/L /g, '⟁L⟁')
          .replace(/C /g, '⟁C⟁')
          .replace(/Z/g, '⟁Z⟁')
          .replace(/,/g, '⟁')
          .replace(/\\s+/g, '⟁');
      }
    }

    // ------------------------------------------------------
    // SVG BRAIN RENDERER (FRONT-END VISUAL CORTEX)
    // ------------------------------------------------------
    class SVGBrainRenderer {
      constructor(containerId) {
        this.container = document.getElementById(containerId);
      }

      clear() {
        while (this.container.firstChild) {
          this.container.removeChild(this.container.firstChild);
        }
      }

      render(brain) {
        this.clear();

        const title = document.getElementById('brainTitle');
        const overlay = document.getElementById('brainOverlay');
        title.textContent = `${brain.model} — ${brain.id}`;
        this.container.appendChild(title);
        this.container.appendChild(overlay);

        const ns = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(ns, 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 240 140');

        brain.layers.forEach((layer, idx) => {
          const g = document.createElementNS(ns, 'g');
          g.setAttribute('class', 'neural-layer');
          g.setAttribute('transform', `translate(10,${15 + idx * 35})`);

          const label = document.createElementNS(ns, 'text');
          label.setAttribute('x', 0);
          label.setAttribute('y', -4);
          label.setAttribute('fill', '#9ca3af');
          label.setAttribute('font-size', '6');
          label.setAttribute('font-family', 'monospace');
          label.textContent = layer.name;
          g.appendChild(label);

          layer.paths.forEach(p => {
            const path = document.createElementNS(ns, 'path');
            path.setAttribute('d', p.d);
            path.setAttribute('stroke', p.stroke);
            path.setAttribute('stroke-width', p.width || 1.2);
            path.setAttribute('fill', 'none');
            path.style.opacity = 0.75;
            path.classList.add('weight-path');

            path.addEventListener('mouseenter', () => {
              path.style.strokeWidth = (p.width || 1.2) * 1.8;
              path.style.opacity = 1;
            });
            path.addEventListener('mouseleave', () => {
              path.style.strokeWidth = p.width || 1.2;
              path.style.opacity = 0.75;
            });

            g.appendChild(path);
          });

          svg.appendChild(g);
        });

        this.container.appendChild(svg);
      }
    }

    const brainRenderer = new SVGBrainRenderer('brainContainer');
    const geometryEngine = new SVGWeightGeometry();
    const svgCompressor = new SVGQLoRACompressor();

    // ------------------------------------------------------
    // SW UTILS
    // ------------------------------------------------------
    const logEl = document.getElementById('log');
    const statusLine = document.getElementById('statusLine');
    const brainCountEl = document.getElementById('brainCount');
    const procCountEl = document.getElementById('procCount');
    const brainSelect = document.getElementById('brainSelect');
    const svgStatus = document.getElementById('svgStatus');

    const demoWeights = {
      lora_A: {
        rank: 2,
        shape: [24, 48],
        data: Array.from({ length: 24 }, (_, i) => (
          Array.from({ length: 48 }, (_, j) => (
            Math.sin(i * 0.25) * Math.cos(j * 0.15) * 0.6
          ))
        ))
      },
      lora_B: {
        rank: 2,
        shape: [16, 36],
        data: Array.from({ length: 16 }, (_, i) => (
          Array.from({ length: 36 }, (_, j) => (
            Math.cos(i * 0.3) * Math.sin(j * 0.2) * 0.4
          ))
        ))
      }
    };

    const demoArchitecture = {
      name: 'ULTRA-QLoRA',
      layers: [
        { name: 'lora_A', activation: 'relu' },
        { name: 'lora_B', activation: 'tanh' }
      ]
    };

    function log(msg) {
      const time = new Date().toISOString().split('T')[1].replace('Z','');
      logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
    }

    async function registerSW() {
      if (!('serviceWorker' in navigator)) {
        statusLine.textContent = 'Kernel: service workers unsupported';
        return;
      }
      const reg = await navigator.serviceWorker.register('/sw.js');
      statusLine.textContent = 'Kernel: registering…';
      log('Service worker registration requested');

      navigator.serviceWorker.addEventListener('message', ev => {
        if (ev.data?.type === 'ΩOS:kernel_ready') {
          statusLine.textContent = 'Kernel: ready';
          brainCountEl.textContent = `Brains: ${ev.data.brains.length}`;
          procCountEl.textContent = `Processes: 0`;
          populateBrains(ev.data.brains);
          log('Kernel broadcast: ready');
        }
      });

      await navigator.serviceWorker.ready;
      statusLine.textContent = 'Kernel: ready (await)';
      log('Service worker ready');

      await refreshStatus();
    }

    function sendMessage(type, payload) {
      return new Promise(resolve => {
        if (!navigator.serviceWorker.controller) {
          resolve(null);
          return;
        }
        const channel = new MessageChannel();
        channel.port1.onmessage = ev => resolve(ev.data);
        navigator.serviceWorker.controller.postMessage({ type, payload }, [channel.port2]);
      });
    }

    async function refreshStatus() {
      const res = await sendMessage('ΩOS:status', {});
      if (!res) return;
      statusLine.textContent = 'Kernel: online';
      brainCountEl.textContent = `Brains: ${res.brains.length}`;
      procCountEl.textContent = `Processes: ${res.k.processes}`;
      populateBrains(res.brains);
      log('Status refreshed from ΩOS');
    }

    function populateBrains(brains) {
      brainSelect.innerHTML = '';
      brains.forEach(b => {
        const opt = document.createElement('option');
        opt.value = b.id;
        opt.textContent = `${b.model} (${b.id})`;
        brainSelect.appendChild(opt);
      });
      if (!brains.length) {
        const opt = document.createElement('option');
        opt.textContent = 'No brains in registry';
        opt.disabled = true;
        opt.selected = true;
        brainSelect.appendChild(opt);
      }
    }

    async function fetchBrainsList() {
      const res = await fetch('/api/ΩOS/brains/list').catch(() => null);
      if (!res || !res.ok) {
        log('Brains list fetch failed');
        return;
      }
      const json = await res.json();
      populateBrains(json.brains || []);
      brainCountEl.textContent = `Brains: ${json.brains.length}`;
      log(`Brain list updated (${json.brains.length})`);
    }

    async function renderSelectedBrain() {
      const id = brainSelect.value;
      if (!id) return;
      const res = await fetch(`/api/ΩOS/brains/get/${encodeURIComponent(id)}`).catch(() => null);
      if (!res || !res.ok) {
        log(`Failed to fetch brain ${id}`);
        return;
      }
      const json = await res.json();
      if (!json.brain) {
        log(`No brain payload for ${id}`);
        return;
      }
      brainRenderer.render(json.brain);
      log(`Rendered brain: ${json.brain.model} (${json.brain.id})`);
    }

    function renderGeneratedBrain(networkSVG) {
      const brain = {
        id: 'generated_svg',
        model: networkSVG.metadata.architecture,
        layers: networkSVG.layers.map(layer => ({
          name: layer.layer,
          paths: layer.paths.map(path => ({
            d: path.d,
            stroke: path.stroke,
            width: path.width
          }))
        }))
      };
      brainRenderer.render(brain);
    }

    async function generateSVGBrain() {
      const networkSVG = geometryEngine.networkToSVG(demoWeights, demoArchitecture);
      svgStatus.textContent = 'Geometry: generated';
      log('Generated SVG geometry from demo weights');
      renderGeneratedBrain(networkSVG);
    }

    async function compressSVGBrain() {
      const result = await svgCompressor.compressQLoRAToSVG(
        demoWeights,
        demoArchitecture.name,
        { quantization: 8, compression: 'scxq2' }
      );
      svgStatus.textContent = `Geometry: compressed (${result.compressionRatio.toFixed(2)}x)`;
      log(`Compressed SVG brain to SCXQ2 (${result.compressionRatio.toFixed(2)}x)`);
    }

    // ------------------------------------------------------
    // WIRE UI
    // ------------------------------------------------------
    document.getElementById('btnRefresh').addEventListener('click', refreshStatus);
    document.getElementById('btnListBrains').addEventListener('click', fetchBrainsList);
    document.getElementById('btnRenderBrain').addEventListener('click', renderSelectedBrain);
    document.getElementById('btnGenerateSVG').addEventListener('click', generateSVGBrain);
    document.getElementById('btnCompressSVG').addEventListener('click', compressSVGBrain);

    // ------------------------------------------------------
    // BOOT
    // ------------------------------------------------------
    registerSW().catch(err => {
      console.error(err);
      statusLine.textContent = 'Kernel: registration error';
      log('Error registering service worker');
    });
  </script>
</body>
</html>
